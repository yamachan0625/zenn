---
title: '第2部 戦術的設計 (コード実装)'
---

# 戦術的設計とは

戦術的設計とは、ビジネスの複雑性をコードにどのように反映させるか、具体的なアプローチやパターンに焦点を当てたものです。第 1 部で行ったドメインモデリングでの成果物をドメイン駆動設計のアプローチやパターン (値オブジェクト、エンティティ、集約、リポジトリなど) を紹介すると共に実際にコードに反映していきます。

# アーキテクチャ

ここでアーキテクチャに触れておきましょう。ドメイン駆動設計には固有のアーキテクチャはありません。ここでのアーキテクチャとは、ソフトウェアアプリケーションを構築する際の設計思想と構造計画であり、ドメイン駆動設計のアプローチやパターンをどのように実装するかを決めるものです。良いアーキテクチャは、要件の変更や新しい技術の採用に柔軟に対応し、システムのパフォーマンス、スケーラビリティ、セキュリティを最適化する手助けとなります。

アーキテクチャにはレイヤードアーキテクチャ、オニオンアーキテクチャ、ヘキサゴナルアーキテクチャ、クリーンアーキテクチャなどさまざまな種類があります。この本ではドメイン駆動設計のアーキテクチャに**オニオンアーキテクチャ**を採用しています。

## オニオンアーキテクチャとは

オニオンアーキテクチャは、ソフトウェアの設計パターンの一つで、アプリケーションを複数のレイヤーで構成し、それらを円形に配置することを特徴とします。このアーキテクチャは、ドメイン駆動設計との相性が良く、ドメイン駆動設計のアプローチやパターンを実装するのに適しています。

## オニオンアーキテクチャの特徴

オニオンアーキテクチャは一般的に以下のような図で表現されます。
![](https://storage.googleapis.com/zenn-user-upload/0852995fe722-20240108.png)

この図を参考にオニオンアーキテクチャの特徴を見ていきましょう。

### ドメイン中心の設計

オニオンアーキテクチャは、アプリケーションの中心にドメインモデル（ビジネスロジック）を置き、他の層はこのドメインモデルを取り囲む形で構築されます。**ドメイン層が他の層に依存しない**ようにすることで、ドメインモデルを独立して開発することができます。

### レイヤー構造

オニオンアーキテクチャでは、アプリケーションを複数のレイヤーに分割します。ドメイン駆動設計において各レイヤーにはそれぞれ以下のような役割があります。

| レイヤー                   | 説明                                                                                                                                                                                   |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ドメイン層**             | これはアプリケーションのコアであり、ビジネスルールやビジネスロジックを表現します。主にエンティティ、値オブジェクト、ドメインサービス、およびリポジトリのインターフェイスが含まれます。 |
| **アプリケーション層**     | アプリケーション層はドメイン層のクライアントです。ユースケースを組み立てるためにドメイン層を使用します。主にアプリケーションサービスが含まれます。                                     |
| **インフラストラクチャ層** | この層はアプリケーションに必要な外部リソース (データベース、ファイルシステム、外部サービス) への通信を担当します。主にリポジトリの実装が含まれます。                                   |
| **プレゼンテーション層**   | ユーザーのリクエストを受け取り、適切な応答を返します。主に `Web UI`、`REST API`、`CLI` などが含まれます。                                                                              |

### 依存関係の方向の制限

オニオンアーキテクチャでは、依存関係に明確な方向性があります。このアーキテクチャは、外側のレイヤー（アプリケーション層やインフラ層）から内側のレイヤー（ドメイン層）への一方向の依存関係を強制します。このようにすることで、以下のようなメリットがあります。

- **ドメイン層の独立性**
  ドメイン層はアプリケーションのビジネスロジックの中心であり、他の層に依存しないようにすることが重要です。これにより、ビジネスロジックが他の層の変更に影響を受けることがなくなり、ドメインモデルを独立して開発することができます。

- **テストの容易性**
  ドメイン層が他の層に依存しないため、単体テストが容易になります。ビジネスロジックを他の層から分離することで、モックやスタブを使用せずにテストを行うことができ、テストの容易性が向上します。

- **拡張性と保守性の向上**
  各層が特定の責任を持ち、依存関係を制御することで、システムの変更が容易になります。たとえば、インフラストラクチャ層の変更がドメイン層に影響を及ぼすことはありません。これにより、新しい機能の追加や既存機能の変更がより容易になります。

- **再利用性の向上**
  ドメイン層が独立しているため、ビジネスロジックを使い回すことができます。これは、ドメイン層がアプリケーションやインフラストラクチャの特定の実装に依存しないことによるものです。

## 依存性逆転の原則 (DIP）

オニオンアーキテクチャにおける依存関係の方向性は、「依存性逆転の原則 (Dependency Inversion Principle, DIP) 」というソフトウェア設計の原則を反映しています。この原則は以下の二つのポイントで構成されています。

- **上位モジュールは下位モジュールに依存してはならない。どちらのモジュールも抽象に依存すべきである**
  ビジネスロジックを含む上位モジュール (ドメイン層) は、データアクセスや外部 API のような下位モジュール (インフラストラクチャ層やプレゼンテーション層) に依存してはいけません、。そして、どちらのモジュールも抽象に依存すべきです。

- **抽象は詳細に依存してはならない。詳細が抽象に依存すべきである**
  抽象 (インターフェイスや抽象クラス) は詳細 (具体的な実装) に依存せず、詳細は抽象に依存すべきです。

具体的には「依存性の注入 (Dependency injection, DI) 」を利用することで、依存関係を制御します。

### DI (Dependency injection) とは

DI とは、ソフトウェア設計の手法であり、コンポーネント間の依存関係を外部から注入することによって、コードの柔軟性と再利用性を高めるアプローチです。具体的には、あるオブジェクトが必要とする依存オブジェクト（サービス、ツール、クライアントなど）を、そのオブジェクトの内部で生成するのではなく、外部から提供 (注入) することを意味します。

DI を用いると何が嬉しいのかを簡単な例で見てみましょう。以下のコードでは、`sayHello`関数が`logger`を呼び出しています。

```js
const sayHello = (name: string): void => {
  logger(`Hello ${name}!`);
};

sayHello('World');
```

このコードは、`sayHello`関数が`logger`を呼び出しているため、`logger`の実装を変更すると`sayHello`関数に影響を与えます。これは、`sayHello`関数が`logger`に強く依存しているためです。この問題を解決するために、DI を利用します。

```js
const sayHello = (name: string, logger: (message: string) => void): void => {
  logger(`Hello ${name}!`);
};

sayHello('World', console.log);
```

`sayHello`関数は、`logger`を注入することで、`logger`の実装を変更しても`sayHello`関数に影響を与えなくなります。これにより、ロギングツールが決まるまで`console.log`で代用するることができたり、ロギングツールの変更が容易になるなどのメリットがあります。

このように、DI を利用することで、依存関係の方向性を制御し、依存性逆転の原則を実現します。依存性逆転の原則を適用することで、結果としてシステムの保守性、拡張性、テスト容易性が向上します。

:::message
オニオンアーキテクチャを利用してレイヤーを分離し、依存関係を制御する事によるメリットは、まだあまり感じられていないでしょう。第 2 部では DI を利用するシーンが多く登場します。実際にコードを書きながら理解していきましょう。
:::

# 環境のセットアップ

次の章に進む前に、`TypeScript` の環境をセットアップしましょう。
`node` のバージョンは 「18.15.0」 です。

```bash
$ node -v
v18.15.0
```

### npm プロジェクトの初期化

```bash:
$ npm init -y
```

### src ディレクトリの作成

`src` ディレクトリを作成し `Domain`ディレクトリを`src`ディレクトリ配下に移動します。

```bash:
$ mkdir src && mv Domain/ src/
```

### パッケージのインストール

必要なパッケージをインストールしていきます。

```bash:
$ npm i -D typescript ts-node tsconfig-paths @types/node jest ts-jest @types/jest
```

### TypeScript の設定

`tsconfig.json`を作成し以下のように、設定を行なってください。オプションはお好みで追加してください。

```json:tsconfig.json
{
  "ts-node": {
    "require": ["tsconfig-paths/register"]
    // ts-nodeがtsconfigのpathsを解決できるようにします。
  },
  "compilerOptions": {
    "outDir": "./dist",
    "strict": true,
    "resolveJsonModule": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "baseUrl": "./",
    "paths": {
      "*": ["./src/*"]
    },
    "esModuleInterop": true
  },
  "include": ["src/**/*.ts", "src/**/*.js"],
  "exclude": ["node_modules"]
}
```

### TypeScript の動作確認

`sayHello.ts`を作成し以下のようにコードを記述します。

```js:src/sayHello.ts
export const sayHello = (name: string): void => {
  console.log(`Hello ${name}!`);
};

sayHello('World');

```

```bash:
$ ts-node src/sayHello.ts
```

`ts-node`コマンドで実行し、ターミナルに「Hello World!」と表示されば OK です。

### Jest の設定

テストには`jest`を利用します。まず`jest.config.js`を作成し以下のように設定を行なってください。

```js:jest.config.js
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  moduleDirectories: ['node_modules', 'src'],
  transformIgnorePatterns: ['/node_modules'],
};
```

### Jest の動作確認

`src`ディレクトリ配下に`sayHello.test.ts`を作成し以下のように実装します。

```js:src/sayHello.test.ts
import { sayHello } from './sayHello';

test('sayHello', () => {
  expect(sayHello('World')).toBe('Hello World');
});

```

```bash:
$ jest src/sayHello.test.ts
```

`jest`コマンドでテストを実行し、テストに成功すれば OK です。
`sayHello.ts`と`sayHello.test.ts`は以降使用しないため削除しましょう。

# まとめ

本章では、戦術的設計のアプローチやパターンを紹介し、オニオンアーキテクチャを採用した理由を説明しました。また、オニオンアーキテクチャの特徴や依存性逆転の原則についても説明しました。最後に、環境のセットアップを行いました。

次章から戦術的設計の各アプローチををれぞれ詳しく確認しながらコードの実装を行なっていきましょう。

### これまでのコード

https://github.com/yamachan0625/ddd-hands-on/tree/setup
